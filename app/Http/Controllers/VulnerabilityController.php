<?php

namespace App\Http\Controllers;

use App\Exports\VulnerabilityExport;
use App\Helpers\LogHelper;
use App\Http\Resources\CommonResource;
use App\Http\Resources\VulnerabilityResource;
use App\Models\Asset;
use App\Models\Exploits;
use App\Models\Patch;
use App\Models\Vulnerability;
use App\Models\Vulnerable;
use Illuminate\Http\Request;
use App\ResponseApi;
use Illuminate\Support\Carbon;
use Maatwebsite\Excel\Facades\Excel;
use ZipArchive;

class VulnerabilityController extends Controller
{
    use ResponseApi;

    /**
     * Index page
     */
    public function index()
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $search = request('search');
        $sort_column = request('sort_column');

        $sort_direction = request('sort_direction');
        $filter = json_decode(request('filter')) ?? null;
        $accepted_sort_columns = ['name', 'severity', 'social_score', 'created_at'];


        try {
            $vulnerabilities = Vulnerability::select('id', 'name', 'description', 'first_seen', 'risk', 'social_score', 'severity')
                ->withCount([
                    'assetrelations as asset_count' => function ($q_asset) use ($orgId) {
                        $q_asset->whereHas('vulnerabilities', function ($query) use ($orgId) {
                            $query->where('organization_id', $orgId);
                        });
                    }
                ])
                ->withCount('exploits')
                ->with('tags')
                ->whereHas('assetrelations', function ($asset) use ($orgId) {
                    $asset->where('organization_id', $orgId);
                })
                ->search($search, ['description', 'severity', 'social_score'])
                ->when($filter, fn($query) => $query->filter($filter))
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->orderBy('risk', 'desc')
                ->paginateresults();

            $vulnerabilityRecords = VulnerabilityResource::collection($vulnerabilities)->response()->getData(true);

            return $this->sendResponse($vulnerabilityRecords, 'Vulnerabilities displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    public function count(Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        try {
            $vulnerabilitiesQuery = Vulnerability::whereHas('assetrelations', function ($asset) use ($orgId) {
                $asset->where('organization_id', $orgId);
            });

            $critical = (clone $vulnerabilitiesQuery)->where('severity', 'critical')->count();
            $high = (clone $vulnerabilitiesQuery)->where('severity', 'high')->count();
            $low = (clone $vulnerabilitiesQuery)->where('severity', 'low')->count();
            $medium = (clone $vulnerabilitiesQuery)->where('severity', 'medium')->count();

            $result = [
                'total' => $vulnerabilitiesQuery->count(),
                'critical' => $critical,
                'high' => $high,
                'medium' => $medium,
                'low' => $low,
            ];
            return $this->sendResponse($result, 'Vulnerability count displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * Export functionality
     */
    public function export()
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $is_password = request()->boolean('is_password');
        $password = request('password');
        $selectedId = request('selectedId') ? explode(',', request('selectedId')) : null;
        $filter = json_decode(request('filter')) ?? null;
        $accepted_sort_columns = ['name', 'severity', 'social_score', 'created_at'];

        try {
            deleteExportFolder();
            createExportFolder();

            $vulnerabilitiesQuery = Vulnerability::withCount('exploits', 'patches')
                ->whereHas('assetrelations', function ($asset) use ($orgId) {
                    $asset->where('organization_id', $orgId);
                })
                ->withCount([
                    'assetrelations as asset_count' => function ($q_asset) use ($orgId) {
                        $q_asset->whereHas('vulnerabilities', function ($query) use ($orgId) {
                            $query->where('organization_id', $orgId);
                        });
                    }
                ])
                ->when($selectedId, function ($ids) use ($selectedId) {
                    $ids->whereIn('id', $selectedId);
                })
                ->search($search, ['description', 'severity', 'social_score'])
                ->when($filter, fn($query) => $query->filter($filter))
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->orderBy('risk', 'desc')
                ->get();

            $data = $vulnerabilitiesQuery->select('name', 'description', 'risk', 'social_score', 'severity', 'first_seen', 'last_identified_on', 'patch_priority', 'impact', 'solution', 'workaround', 'result', 'patches_count', 'exploits_count', 'assets', 'cve_data', 'asset_count');

            $now = Carbon::now();
            $dt = $now->format('Y_m_d_H_i_s_v');

            $export = new VulnerabilityExport($data);
            // Generate a unique filename with the current timestamp
            $filename = 'scani5_vulnerabilities_export_' . $dt . '.xlsx';
            Excel::store($export, 'exports/' . $filename, 'public');

            if ($is_password) {
                if (!$password) {
                    return $this->sendError('Password is empty');
                }

                $filePath = storage_path('app/public/exports/' . $filename);
                $zip = new ZipArchive();
                $fanme = 'scani5_vulnerabilities_export_' . $dt . '.zip';
                resetExportFolder();
                $zipFileName = public_path('exports/' . $fanme);

                if ($zip->open($zipFileName, ZipArchive::CREATE | ZipArchive::OVERWRITE) === true) {
                    if (file_exists($filePath)) {
                        $zip->addFile($filePath, basename($filePath));
                        $zip->setPassword($password);
                        $zip->setEncryptionName(basename($filePath), ZipArchive::EM_TRAD_PKWARE);
                        $zip->close();
                        $url = [
                            'file' => $fanme,
                            'fileName' => exportFileName($orgId, 'vulnerabilities', 'zip'),
                        ];

                        LogHelper::logAction('Exported', 'Vulnerability', 'User exported the vulnerabilities', getRoleId(), $orgId);
                        return $this->sendResponse($url, 'Vulnerabilities exported successfully');
                    } else {
                        return $this->sendError('File not found', null, 404);
                    }
                } else {
                    return $this->sendError('Failed to create the zip file.');
                }
            } else {
                $url = [
                    'file' => $filename,
                    'fileName' => exportFileName($orgId, 'vulnerabilities', 'xlsx'),
                ];

                LogHelper::logAction('Exported', 'Vulnerability', 'User exported the vulnerabilities', getRoleId(), $orgId);
                return $this->sendResponse($url, 'Vulnerabilities exported successfully');
            }
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     *  Get Available Patches
     */
    public function patches($id)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $vulnerability = Vulnerability::whereId($id)
            ->whereHas('assetrelations', function ($asset) use ($orgId) {
                $asset->where('organization_id', $orgId);
            })
            ->orWhereHas('assetrelationsTrashed', function ($asset) use ($orgId) {
                $asset->where('organization_id', $orgId);
            })
            ->first();

        if (!$vulnerability) {
            return $this->sendError('Vulnerability not found', null, 404);
        }

        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $accepted_sort_columns = ['solution', 'description', 'complexity', 'type'];
        $filter = json_decode(request('filter')) ?? null;
        try {
            $patches = Patch::where('vul_id', $id)
                ->search($search, ['solution', 'description', 'complexity', 'type', 'os'])
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->when($filter, fn($query) => $query->filter($filter))
                ->when(is_null($sort_column), function ($query) {
                    $query->orderByRaw("FIELD(complexity, 'critical', 'high', 'medium', 'low')");
                })
                ->paginateresults();
            $patchRec = CommonResource::collection($patches)->response()->getData(true);
            return $this->sendResponse($patchRec, 'Patch displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    public function cve($id, Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $vulnerability = Vulnerability::select('CVEs')->whereId($id)
            ->whereHas('assetrelations', function ($asset) use ($orgId) {
                $asset->where('organization_id', $orgId);
            })->first();

        if (!$vulnerability) {
            return $this->sendError('Vulnerability not found', null, 404);
        }

        $response = [
            'data' => $vulnerability->cve_data,
        ];
        return $this->sendResponse($response, 'CVEs displayed successfully.');
    }

    /**
     * total Exploits
     */
    public function totalExploits(Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $accepted_sort_columns = ['name', 'description', 'complexity', 'dependency', 'created_at'];

        $vulIds = Vulnerability::whereHas('assetrelations', function ($q) use ($orgId) {
            $q->where('organization_id', $orgId);
        })->pluck('id');

        try {
            $exploits = Exploits::withCount('vulnerabilities')->whereIn('vul_id', $vulIds)
                ->search($search, ['description', 'name', 'complexity', 'dependency'])
                ->when(is_null($sort_column), function ($query) {
                    $query->orderByRaw("FIELD(complexity, 'critical', 'high', 'medium', 'low')");
                })
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->paginateresults();

            $exploitsRec = CommonResource::collection($exploits)->response()->getData(true);

            return $this->sendResponse($exploitsRec, 'Exploits displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * count total Exploits
     */
    public function countExploits($vulId = null)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        try {
            $exploits = Exploits::whereHas('vulnerabilities', function ($q) use ($orgId, $vulId) {
                $q->whereHas('assetrelations', function ($a) use ($orgId) {
                    $a->where('organization_id', $orgId);
                })
                    ->when($vulId, function ($ids) use ($vulId) {
                        $ids->where('vul_id', $vulId);
                    });
            })->count();

            $result = [
                'total' => $exploits,
            ];
            return $this->sendResponse($result, 'Total exploits displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * count total Patches
     */
    public function countPatches($vulId = null)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        try {
            $patches = Patch::where('vul_id', $vulId)

                ->count();

            $result = [
                'total' => $patches,
            ];
            return $this->sendResponse($result, 'Total patches displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * Get Exploits
     */
    public function exploits($id, Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $accepted_sort_columns = ['name', 'description', 'complexity', 'dependency', 'created_at'];

        $vulIds = Vulnerable::where('asset_id', $id)->pluck('vulnerability_id');

        try {
            $exploits = Exploits::withCount('vulnerabilities')->whereIn('vul_id', $vulIds)
                ->search($search, ['description', 'name', 'complexity', 'dependency'])
                ->when(is_null($sort_column), function ($query) {
                    $query->orderByRaw("FIELD(complexity, 'critical', 'high', 'medium', 'low')");
                })
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->paginateresults();
            return $this->sendResponse($exploits, 'Exploits displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError('An error occurred while fetching exploits.');
        }
    }

    /**
     * Get Vulnerability Exploit
     */
    public function vulnerabilityExploits($id, Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $accepted_sort_columns = ['name', 'description', 'complexity', 'dependency', 'created_at'];
        $filter = json_decode(request('filter')) ?? null;

        try {
            $exploits = Exploits::select('name', 'description', 'complexity', 'dependency', 'created_at')
                ->where('vul_id', $id)
                ->search($search, ['description', 'name', 'complexity', 'dependency'])
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->when($filter, fn($query) => $query->filter($filter))
                ->when(is_null($sort_column), function ($query) {
                    $query->orderByRaw("FIELD(complexity, 'critical', 'high', 'medium', 'low')");
                })
                ->paginateresults();

            $exploitsRec = CommonResource::collection($exploits)->response()->getData(true);

            return $this->sendResponse($exploitsRec, 'Exploits displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * Get Exploits Vulnerability
     */
    public function exploitsVulnerability($id, Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $accepted_sort_columns = ['name', 'description', 'complexity', 'dependency', 'created_at'];

        try {
            $vulnerabilities = Vulnerability::select('id', 'name', 'risk', 'severity', 'first_seen', 'patch_priority', 'last_identified_on')
                ->withCount('patches')
                ->search($search, ['name', 'risk', 'severity', 'patch_priority'])
                ->sort($sort_column, $sort_direction, $accepted_sort_columns)
                ->whereId($id)
                ->paginateresults();
            return $this->sendResponse($vulnerabilities, 'Vulnerabilities displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * Fetch vulnerability details
     */
    public function details($id, Request $request)
    {
        $type = request('type') == 'retired' ? 'retired' : 'active';
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        try {
            $vulnerability = Vulnerability::select([
                'id',
                'CVEs',
                'name',
                'social_score',
                'description',
                'risk',
                'severity',
                'first_seen as discovered_date',
                'updated_at as updated_on',
                'created_at as published_date',
                'patch_priority',
                'solution',
                'workaround',
                'impact',
                'result',
                'last_identified_on as last_found',
                'status'
            ])
                ->when(in_array($type, ['retired', 'active']), function ($query) use ($type, $orgId) {
                    $relation = $type == 'retired' ? 'assetrelationsTrashed' : 'assetrelations';
                    $query->whereHas($relation, function ($q) use ($orgId) {
                        $q->where('organization_id', $orgId);
                    });
                })
                ->where('id', $id)
                ->first();

            if (!$vulnerability) {
                return $this->sendError('Vulnerability not found', null, 404);
            }

            $exploitability = Exploits::select('complexity')->where('vul_id', $vulnerability->id)->orderByRaw("FIELD(complexity, 'critical', 'high', 'medium', 'low')")->first();
            $vulnerability->exploitability = $exploitability;
            $vulnerability->updated_on = Carbon::parse($vulnerability->updated_at)->format('d-M-Y');
            $vulnerability->risk_score = getRiskStatus($vulnerability->risk);

            return $this->sendResponse($vulnerability, 'Vulnerability details retrieved successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * Vulnerability assets
     */
    public function assets($id)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        try {
            $assets = Asset::select('host_id', 'host_name', 'ip_address_v4', 'ip_address_v6', 'os', 'severity', 'agent_status', 'created_at as created_on', 'last_user_login', 'Last_scanned as last_activity', 'last_system_boot')
                ->whereHas('vulnerabilities', function ($q) use ($id) {
                    $q->where('vulnerability_id', $id);
                })

                ->search(request('search'), ['host_name', 'host_id', 'ip_address_v4', 'ip_address_v6', 'os', 'severity'])
                ->orderBy('rti_score', 'desc')
                ->paginateresults();

            $assetRecords = CommonResource::collection($assets)->response()->getData(true);

            return $this->sendResponse($assetRecords, 'Assets displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }

    /**
     * Fetch Asset vulnerabilities
     */
    public function assetVulnerabilities($id, Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }

        $type = request('type') == 'retired' ? 'retired' : 'active';
        $search = request('search');
        $sort_column = request('sort_column');
        $sort_direction = request('sort_direction');
        $accepted_sort_columns = ['name', 'severity', 'social_score', 'created_at'];

        $asset_find = Asset::Where('organization_id', $orgId)->where('id', $id)
            ->when($type == 'retired', function ($query) {
                return $query->onlyTrashed();
            })
            ->first();

        if (!$asset_find) {
            return $this->sendError('This asset is not assigned for this organization');
        }

        $vulnerabilitiesQuery = Vulnerability::select(['id', 'CVEs', 'name', 'social_score', 'description', 'risk', 'severity', 'first_seen', 'created_at', 'patch_priority', 'solution', 'workaround', 'impact', 'result', 'last_identified_on'])
            ->withCount(['exploits'])
            ->withCount('assetrelations as asset_count')
            ->search($search, ['name', 'severity', 'risk', 'patch_priority'])
            ->when(in_array($type, ['retired', 'active']), function ($query) use ($type, $orgId, $id) {
                $relation = $type == 'retired' ? 'assetrelationsTrashed' : 'assetrelations';
                $query->whereHas($relation, function ($q) use ($orgId, $id) {
                    $q->where('asset_id', $id);
                });
            })
            ->sort($sort_column, $sort_direction, $accepted_sort_columns)
            ->orderBy('risk', 'desc')
            ->paginateresults();

        $vulnerabilityRecords = VulnerabilityResource::collection($vulnerabilitiesQuery)->response()->getData(true);
        return $this->sendResponse($vulnerabilityRecords, 'Vulnerabilities displayed successfully.');
    }

    public function assetVulnerabilitiesCount($id, Request $request)
    {
        $orgId = request('orgId');
        if (!$orgId) {
            return $this->sendError('Organization is mandatory');
        }
        $type = request('type') == 'retired' ? 'retired' : 'active';
        $asset_find = Asset::Where('organization_id', $orgId)->where('id', $id)
            ->when($type == 'retired', function ($query) {
                return $query->onlyTrashed();
            })
            ->first();

        if (!$asset_find) {
            return $this->sendError('This asset is not assigned for this organization');
        }
        try {
            $vulnerabilitiesQuery = Vulnerability::when(in_array($type, ['retired', 'active']), function ($query) use ($type, $orgId, $id) {
                $relation = $type == 'retired' ? 'assetrelationsTrashed' : 'assetrelations';
                $query->whereHas($relation, function ($q) use ($orgId, $id) {
                    $q->where('asset_id', $id);
                    $q->where('organization_id', $orgId);
                });
            });

            $critical = (clone $vulnerabilitiesQuery)->where('severity', 'critical')->count();
            $high = (clone $vulnerabilitiesQuery)->where('severity', 'high')->count();
            $low = (clone $vulnerabilitiesQuery)->where('severity', 'low')->count();
            $medium = (clone $vulnerabilitiesQuery)->where('severity', 'medium')->count();

            $result = [
                'total' => $vulnerabilitiesQuery->count(),
                'critical' => $critical,
                'high' => $high,
                'medium' => $medium,
                'low' => $low,
            ];
            return $this->sendResponse($result, 'Vulnerability count displayed successfully.');
        } catch (\Exception $e) {
            return $this->sendError($e->getMessage(), null, 500);
        }
    }
}
